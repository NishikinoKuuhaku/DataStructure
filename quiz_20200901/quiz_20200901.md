# 习题 20200901

## 说明

本次习题共 2 道编程题，需要在习题时间结束前完成。

## Q1：不太一样的循环数组队列

**本道题目为交互性题目，你需要按照要求实现模板中给出的函数** （你可以额外添加新的函数来帮助实现给出的函数）

在课程中我们学习了循环数组队列的其中一种实现方法：使用 `front, size` 两个变量分别记录队列的首个元素的下标与大小

而在实际运用中，我们还可以通过一种不太一样的方法来实现循环数组队列：使用 `rear, size` 两个变量分别记录队列的结束元素与大小

请你自己试试如何用这种方法实现循环数组队列

### 需要实现的函数

- `Queue createQueue(int maxsize)` ：创建一个初始化后的队列，其最大容量为 `maxsize`

- `int isEmpty(Queue *q)` ：如果传入的队列为空则返回 `1` ，反之返回 `0`
- `int isFull(Queue *q)` ：如果传入的队列已满则返回 `1` ，反之返回 `0`
- `void inQueue(Queue *q, QUEUE_ELEMENT_TYPE elem)` ：将 `elem` 放入传入的队列，如果队列已满则不做任何操作，而是打印错误信息 `"error: queue is full"`
- `QUEUE_ELEMENT_TYPE outQueue(Queue *q)` ：从传入的队列中取出一个元素并返回，如果队列是空的则不做任何操作，而是打印错误信息 `"error: queue is emplty"`

### 样例

样例调用代码：

```
Queue q = createQueue(3);

inQueue(&q, 0);
inQueue(&q, 1);
inQueue(&q, 2);

inQueue(&q, 999); // print error

printf("%d\n", outQueue(&q));
printf("%d\n", outQueue(&q));
printf("%d\n", outQueue(&q));

printf("%d\n", outQueue(&q)); // print error

inQueue(&q, 9);
inQueue(&q, 8);
printf("%d\n", outQueue(&q));
printf("%d\n", outQueue(&q));
inQueue(&q, 7);
inQueue(&q, 6);
printf("%d\n", outQueue(&q));
printf("%d\n", outQueue(&q));

```

样例输出：

```
error: queue is full
0
1
2
error: queue is empty
0
9
8
7
6
```

### 数据说明

- 队列结构体如下（不可更改）：

  ```c
  typedef struct Queue
  {
      int rear, size;
      int maxsize;
      QUEUE_ELEMENT_TYPE *data;
  }Queue;
  ```

### 考点

- 循环数组
- 动态分配内存

### 额外思考

- 在代码模板中，这个队列保存的是什么类型的数据？
- 如何修改代码能让这个队列可以保存字符 `char` 类型的数据？
- 如何才能用这个队列保存字符串？

## Q2：堆积如山的文件

APD 有个不是很好的文件整理办法。他有一个专门堆放还没处理的文件的地方，每次有人交给 APD 待处理的文件的时候，APD 会随手把新的文件堆在文件堆的最上面。而当 APD 摸鱼结束回来开始工作的时候，他会拿起文件堆最顶上的文件来处理。

有一天，某位甲方突然找到 APD ，质问他为什么之前给他的文件还没有处理完。但是 APD 已经忘记那个文件在文件堆中的哪个位置了，你能帮帮 APD 找到需要处理的文件距离文件堆顶部的距离（中间隔了多少个文件）吗？

### 输入

- 一个 `int` 数组表示 APD 此前收到和处理文件的信息（按时间先后顺序）
  - 如果某位是正数，则其值表示送来的那一份文件的编号
  - 如果某位是负数，则其绝对值表示 APD 结束摸鱼后处理了多少份文件（保证待处理的文件数量大于这个绝对值）
  - 如果某位是 `0` ，则表示这是本数组的结束位置，你无需做任何事情
- 一个 `int` 数字表示需要查找的文件的编号

###  输出

- 一个 `int` 数字表示需要查找的文件与文件堆顶部之间隔了多少份未处理的文件
  - 如果该文件在文件堆顶则返回 `0` ，在下面的情况以此类推
  - 如果该文件不在文件堆中则返回 `-1` ，说明 APD 已经处理过该文件或者该文件没有被送到 APD 手中

### 样例输入

```
[1, 2, 3, 4, 5, -2, 6, 7, 8, 9, -3, 10, 11, -1 , -2, 0]
2
```

### 样例输出

```
1
```

### 样例说明

文件堆的变化过程如下所示（左侧代表底部，右侧代表顶部）：

```python
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
1 2 3
1 2 3 6
1 2 3 6 7
1 2 3 6 7 8
1 2 3 6 7 8 9
1 2 3 6
1 2 3 6 10
1 2 3 6 10 11
1 2 3 6 10
1 2 3
# 结束时，目标文件（文件 2）距离顶部还隔了一份未处理的文件（文件 3），因此输出为 1
```

### 补充说明

- APD 并不会用这种办法处理问题，题目是虚构的
- 你可以使用以前实现过的队列 / 栈的代码

## Q3：字符串的修改

请你编写一个函数，使其具有在字符串中插入和删除的能力

### 输入

- 一个待修改的字符串
- 一个 `int` 表示操作的类型：
  - `1` ：需要进行插入操作
  - `2` ：需要进行删除操作
- 一个 `int` 表示删除或者插入的位置（字符串的头部认为是 `0` 号位置）
- 一个 `void *` 指针：
  - 如果需要进行插入操作，则这个指针指向被插入的字符串的开头 `即为 char * 类型`
  - 如果需要进行删除操作，则这个指针指向需要删除的长度 `即为 int * 类型`

###  输出

- 无需输出，请你直接在待修改的字符串上修改内容

### 样例输入 1

```
“233”
1
0
“2”
```

### 样例输出 1

```python
#第一个字符串被修改为
“2233”
```

### 样例输入 2

```
“abcdefg”
2
3
&2
```

### 样例输出 2

```python
#第一个字符串被修改为
“abcfg”
```

### 限制

- 不允许使用 `string.h`

### 建议

- 建议先自己尝试实现类似 `string.h` 里的 `strlen, strcpy` 函数